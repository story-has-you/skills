# 编程规约

## 常量定义

### 常量使用规范
- 不允许任何魔法值（即未经预先定义的常量）直接出现在代码中
- 在 long 或者 Long 赋值时，数值后使用大写字母 L，不能是小写字母 l，小写容易跟数字混淆
- 不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护
- 常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量
- 如果变量值仅在一个固定范围内变化用 enum 类型来定义

## 代码格式

### 大括号使用规范
- 左大括号前不换行，左大括号后换行
- 右大括号前换行，右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行
- 如果是大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格

### 空格使用规范
- 任何二目、三目运算符的左右两边都需要加一个空格
- 采用 4 个空格缩进，禁止使用 Tab 字符
- 注释的双斜线与注释内容之间有且仅有一个空格
- 在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开
- 单行字符数限制不超过 120 个，超出需要换行

### 换行规范
- 方法参数在定义和传入时，多个参数逗号后面必须加空格
- IDE 的 text file encoding 设置为 UTF-8；IDE 中文件的换行符使用 Unix 格式
- 单个方法的总行数不超过 80 行

## OOP 规约

### 访问控制
- 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可
- 所有的覆写方法，必须加@Override 注解
- 相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object
- 外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响
- 不能使用过时的类或方法

### 对象使用规范
- Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals
- 所有整型包装类对象之间值的比较，全部使用 equals 方法比较
- 任何货币金额，均以最小货币单位且整型类型来进行存储
- 浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断
- 定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配
- 禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象

### 类设计规范
- 关于基本数据类型与包装数据类型的使用标准如下：
  - 所有的 POJO 类属性必须使用包装数据类型
  - RPC 方法的返回值和参数必须使用包装数据类型
  - 所有的局部变量使用基本数据类型
- 定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值
- 序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败
- 构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中
- POJO 类必须写 toString 方法
- 禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx()和 getXxx()方法
- 使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查
- 当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读
- 类内方法定义的顺序依次是：公有方法或保护方法 > 私有方法 > getter / setter 方法
- setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名
- 循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展
- final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：
  - 不允许被继承的类，如：String 类
  - 不允许修改引用的域对象
  - 不允许被覆写的方法
  - 不允许运行过程中重新赋值的局部变量
  - 避免上下文重复使用一个变量，使用 final 关键字可以强制重新定义一个变量
- 慎用 Object 的 clone 方法来拷贝对象
- 类成员与方法访问控制从严：
  - 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private
  - 工具类不允许有 public 或 default 构造方法
  - 类非 static 成员变量并且与子类共享，必须是 protected
  - 类非 static 成员变量并且仅在本类使用，必须是 private
  - 类 static 成员变量如果仅在本类使用，必须是 private
  - 若是 static 成员变量，考虑是否为 final
  - 类成员方法只供类内部调用，必须是 private
  - 类成员方法只对继承类公开，那么限制为 protected

## 日期时间

### 日期格式
- 日期格式化时，传入 pattern 中表示年份统一使用小写的 y
- 在日期格式中分清楚大写的 M 和小写的 m，大写的 H 和小写的 h 分别代表的意义
- 获取当前毫秒数：System.currentTimeMillis(); 而不是 new Date().getTime()
- 不允许在程序任何地方中使用：java.sql.Date、java.sql.Time、java.sql.Timestamp
- 不要在程序中写死一年为 365 天，避免在公历闰年时出现日期转换错误或程序逻辑错误

### 时区处理
- 使用枚举值来指代月份。如果使用数字，注意 Date，Calendar 等日期相关类的月份 month 取值范围从 0 到 11 之间

## 集合处理

### 集合使用规范
- 关于 hashCode 和 equals 的处理，遵循如下规则：
  - 只要覆写 equals，就必须覆写 hashCode
  - 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断
  - Map 的 key 也需要遵守这一规则
- 判断所有集合内部的元素是否为空，使用 isEmpty()方法，而不是 size()==0 的方式
- 在使用 java.util.stream.Collectors 类的 toMap()方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常
- ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常
- 使用 Map 的方法 keySet()/values()/entrySet()返回集合对象时，不可以对其进行添加元素操作
- Collections 类返回的对象，如：emptyList()/singletonList()等都是 immutable list，不可对其进行添加或者删除元素的操作
- 在 subList 场景中，高度注意对父集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常
- 使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组

### 集合初始化
- 使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法
- 泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用 add 方法
- 在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行 instanceof 判断
- 不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式
- 在 JDK7 版本及以上，Comparator 实现类要满足如下三个条件，不然 Arrays.sort，Collections.sort 会抛 IllegalArgumentException 异常
- 集合泛型定义时，在 JDK7 及以上，使用 diamond 语法或全省略
- 集合初始化时，指定集合初始值大小
- 使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历

## 控制语句

### 条件判断
- 在一个 switch 块内，每个 case 要么通过 continue/break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止
- 当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null 判断
- 在 if/else/for/while/do 语句中必须使用大括号
- 在高并发场景中，避免使用"等于"判断作为中断或退出的条件
- 表达异常的分支时，少用 if-else 方式
- 除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句
- 不要在其它表达式（尤其是条件表达式）中，插入赋值语句
- 循环体中的语句要考量性能，以下操作尽量移至循环体外处理：定义对象、变量、获取数据库连接，不必要的 try-catch 操作
- 避免采用取反逻辑运算符
- 公开接口需要进行入参保护，尤其是批量操作的接口
- 下列情形，需要进行参数校验：
  - 调用频次低的方法
  - 执行时间开销很大的方法
  - 需要极高稳定性和可用性的方法
  - 对外提供的开放接口，不管是 RPC/API/HTTP 接口
  - 敏感权限入口
- 下列情形，不需要进行参数校验：
  - 极有可能被循环调用的方法
  - 底层调用频度比较高的方法
  - 被声明成 private 只会被自己代码所调用的方法
